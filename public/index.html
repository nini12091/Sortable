<!DOCTYPE html>
<html>
<head>
	<title>Sortable</title>

	<!-- meta -->
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

	<!-- stylesheet -->
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.1.0/css/bootstrap.min.css" integrity="sha384-9gVQ4dYFwwWSjIDZnLEWnxCjeSWFphJiwGPXr1jddIhOegiu1FwO5qRGvFXOdJZ4" crossorigin="anonymous">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

	<style>
		th {
			background-color: #4d4d4d;
			font-size: 1em;
			font-weight: normal;
			color: white;
		}

		th:hover {
			opacity: 0.9;
		}

		td {
			font-size: 0.7em;
		}

		/* 셀이 hovering 되었을 때의 클래스입니다 */
		.cell-hover {
			background-color: #f2f2f2;
		}

		/* Ascending, Descending 정렬 버튼을 위한 클래스입니다 */
		.cell-sort {
			margin-left: 0.2em;
		}

		/* 텍스트 드래그 방지를 위한 클래스입니다 */
		.noselect {
			-moz-user-select: none;
			-webkit-user-select: none;
			-ms-user-select: none;
			-o-user-select: none;
			user-select: none;    
		}

		.background {
			fill: none;
			stroke: lightgray;
		}

		.foreground {
			fill: none;
			stroke: steelblue;
		}
	</style>
</head>
<body>
	<div class="container">
		<!-- header -->
		<h1 class="display-5 my-3 py-3">Sortable</h1>

		<!-- control buttons -->
		<button type="button" onclick="Control.reset()">Reset</button>

		<!-- parallel coordinates -->
		<svg width="960" height="540"></svg>

		<!-- sort buttons -->
		<form class="mt-3">
			<label><input type="radio" value="sortRelative" name="mode" checked> Sort_relative </label>
			<label><input type="radio" value="sortParallel" name="mode"> Sort_parallel </label>
		</form>

		<!-- sortable -->
		<table id="sortable" class="sortable table table-bordered table-sm">
			<thead>
			</thead>
			<tbody>
			</tbody>
		</table>
	</div>
</body>
<script src="https://d3js.org/d3.v5.min.js"></script>
<script type="text/javascript">

var table = d3.select("#sortable");

const Data = {};
Data.headers = [];
Data.origin = [];
Data.current = []; // filtered data

// initialize sort buttons
d3.selectAll("input[name='mode']")
	.on("change", function(d){
		Table.sort = Control[d3.select(this).attr("value")];
	});

// Load data from assets
d3.csv("data.csv").then(function(data){

	// store to global variable
	Data.origin = data.map(function(d){ return d; });
	Data.current = data;

	// pick headers from first record
	Data.headers = d3.keys(data[0]);

	// parse as number
	data.forEach(function(d){
		d3.keys(d).forEach(function(field){
			if(field !== "name") d[field] = +d[field];
		});
	});

	// formatting cell
	data.forEach(function(d, i){
		d3.keys(d).forEach(function(field){
			d[field] = {
				id: i,
				field: field,
				col: Data.headers.indexOf(field),
				value: d[field],
				visible: true,
				active: false,
				color: null
			};
		});
	});

	// plot
	Table.init();
	PC.init();
});



const Control = {};

Control.reset = function(){
	// reset filtered data first
	PC.reset();

	d3.selectAll(".cell-active")
		.style("background-color", null)
		.each(function(d){
			d.active = false;
			d.color = null;
		})
		.classed("cell-active", false);

	Table.sort = Control.sortRelative;
	Table.sort(d3.keys(Data.origin[0])[0], true); // sort by first field "name"
};

Control.sortRelative = function(field, ascending = true){
	var related = {};
	Data.current.forEach(function(d){
		d3.keys(d).forEach(function(field){
			var id = d[field].id;
			if(!(id in related)){
				related[id] = {};
				Data.headers.forEach(function(field){ related[id][field] = null; });
			}
			related[id][field] = d[field];
		});
	});
	Data.current = d3.values(related).sort(function(a, b){
		return (a[field].value > b[field].value ? true : a[field].value < b[field].value ? false : a[field].id > b[field].id) ^ ascending ? -1 : 1;
	});

	// process sort buttons (toggle status)
	d3.selectAll(".cell-sort").attr("class", function(d){
		if(d.field == field){
			return "cell-sort fa fa-angle-" + (ascending ? "up" : "down") + " text-success";
		}
		d.ascending = true;
		return "cell-sort fa fa-angle-up";
	});

	Table.display();
};

Control.sortParallel = function(field, ascending = true){
	Data.current.map(function(d){
		// pick field
		return d[field];
	}).sort(function(a, b){
		// sort
		return (a.value > b.value ? true : a.value < b.value ? false : a.id > b.id) ^ ascending ? -1 : 1;
	}).forEach(function(d, i){
		Data.current[i][field] = d;
	});

	d3.selectAll(".cell-sort").select(function(d){
		return d.field == field ? this : null;
	}).attr("class", function(d){
		return "cell-sort fa fa-angle-" + (ascending ? "up" : "down") + " text-success";
	});

	Table.display();
};


const Table = {};
Table.el = d3.select("#sortable");
Table.head = Table.el.select("thead");
Table.body = Table.el.select("tbody");
Table.sort = Control.sortRelative;

Table.init = function(){
	Table.head.append("tr")
			.selectAll("th")
			.data(Data.headers.map(function(field){ return { field: field, ascending: true }; }))
		.enter().append("th")
			.attr("class", "noselect")
			.style("text-align", function(d, i){ return i == 0 ? "left" : "center"; }) // align center except first field "name"
			.text(function(d){ return d.field; })
			.on("click", function(d){
				// toggle ascend or descend
				d.ascending = !d.ascending;
				Table.sort(d.field, d.ascending);
			})
			.on("mouseover", function(d){
				d3.selectAll(".cell-col-" + d.col).classed("cell-hover", true);
			})
			.on("mouseout", function(d){
				d3.selectAll(".cell-col-" + d.col).classed("cell-hover", false);
			})
		.append("i")
			.style("font-weight", "bolder")
			.attr("class", "cell-sort fa fa-angle-up");

	Table.display();
};

Table.display = function(){
	var rows = Table.body.selectAll("tr")
		.data(Data.current);

	rows.exit().remove();

	rows.enter().append("tr")
			.selectAll("td")
			.data(function(d){ return d3.values(d); })
		.enter().append("td")
			.style("text-align", function(d, i){ return i == 0 ? "left" : "center"; })
			.on("mouseover", function(d){
				d3.selectAll(".cell-row-" + d.id).classed("cell-hover", true);
			})
			.on("mouseout", function(d){
				d3.selectAll(".cell-row-" + d.id).classed("cell-hover", false);
			})
			.on("click", function(d){
				var active = d.active = !d.active;
				d3.selectAll(".cell-row-" + d.id)
					.classed("cell-active", d.active)
					.each(function(d){ d.color = (d.active = active) ? d3.interpolateSinebow(d.id / Data.origin.length) : null; })
					.style("background-color", function(d){ return d.color; });
			});

	Table.body.selectAll("tr")
		.selectAll("td")
		.data(function(d){ return d3.values(d); })
		.attr("class", function(d){ return "cell-col-" + d.col + " cell-row-" + d.id; })
		.classed("cell-active", function(d){ return d.active; })
		.style("background-color", function(d){ return d.color; })
		.text(function(d){ return d.value; });
};

// Parallel Coordinates
const PC = {};
PC.el = d3.select("svg");
PC.margin = { top: 40, right: 10, bottom: 20, left: 20 };
PC.width = PC.el.attr("width") - PC.margin.left - PC.margin.right;
PC.height = PC.el.attr("height") - PC.margin.top - PC.margin.bottom;
PC.svg = PC.el.append("g").attr("transform", "translate(" + PC.margin.left + "," + PC.margin.top + ")");
PC.g = {};

// currently dragging axis
PC.dragging = {};

// position contains dragging
PC.position = function(field){
	return field in PC.dragging ? PC.dragging[field] : PC.x(field);
}

PC.axis = d3.axisLeft();
PC.line = d3.line();

PC.brush = function(field){
	return function(){
		PC.y[field].selection = d3.event.selection;
		var actives = PC.headers.filter(function(field){ return PC.y[field].selection; });

		var visible = {};
		PC.g.foreground.style("display", function(d){
			return visible[d[PC.headers[0]].id] = actives.every(function(field, i){
				return PC.y[field].selection[0] <= PC.y[field](d[field].value) && PC.y[field](d[field].value) <= PC.y[field].selection[1];
			}) ? null : "none";
		});

		// process table data
		var parallelData = {};
		Data.headers.forEach(function(field){
			parallelData[field] = [];
		});
		Data.origin.forEach(function(d){
			Data.headers.forEach(function(field){
				if(visible[d[field].id] != "none") parallelData[field].push(d[field]);
			});
		});

		Data.current = [];
		while(parallelData[field].length > 0){
			var d = {};
			Data.headers.forEach(function(field){
				d[field] = parallelData[field].shift();
			});
			Data.current.push(d);
		}

		// plot data
		Table.display();
	};
};

PC.update = function(){
	PC.g.background.attr("d", PC.path);

	PC.g.foreground.attr("d", PC.path);

	PC.g.axis.attr("transform", function(d){ return "translate(" + PC.x(d) + ")"; });
};

PC.init = function(){
	PC.headers = Data.headers.filter(function(field, i){ return i != 0; }); // except first field "name"

	PC.x = d3.scaleBand().domain(PC.headers).range([0, PC.width]);
	PC.y = {};

	PC.headers.forEach(function(field){
		PC.y[field] = d3.scaleLinear()
			.domain(d3.extent(Data.origin, function(d){ return +d[field].value; }))
			.range([PC.height, 0])
			.nice();
	});

	PC.path = function(d){ return PC.line(PC.headers.map(function(field){ return [PC.position(field), PC.y[field](d[field].value)]; })); };
	PC.g.background = PC.svg.append("g")
			.attr("class", "background")
			.selectAll("path")
			.data(Data.origin)
		.enter().append("path");

	PC.g.foreground = PC.svg.append("g")
			.attr("class", "foreground")
			.selectAll("path")
			.data(Data.origin)
		.enter().append("path");

	PC.g.axis = PC.svg.selectAll(".header")
			.data(PC.headers)
		.enter().append("g")
			.attr("class", "header")
			.call(d3.drag()
				.subject(function(){ return d3.select(this); })
				.on("start", function(field){
					PC.dragging[field] = PC.x(field);
					PC.g.background.attr("visibility", "hidden");
				})
				.on("drag", function(field){
					PC.dragging[field] = Math.min(PC.width, Math.max(-1, d3.event.x));
					PC.g.foreground.attr("d", PC.path);
					PC.headers.sort(function(a, b){ return PC.position(a) - PC.position(b); });
					PC.x.domain(PC.headers);
					PC.g.axis.attr("transform", function(field){ return "translate(" + PC.position(field) + ")"; });
				})
				.on("end", function(field){
					delete PC.dragging[field];
					d3.select(this).transition().attr("transform", "translate(" + PC.x(field) + ")");
					PC.g.foreground.transition().attr("d", PC.path);
					PC.g.background
							.attr("d", PC.path)
						.transition()
							.delay(500)
							.duration(0)
							.attr("visibility", null);
				}));

	PC.g.axis.append("g")
			.attr("class", "axis")
			.each(function(field){ d3.select(this).call(PC.axis.scale(PC.y[field])); })
		.append("text")
			.style("text-anchor", "middle")
			.style("font-size", "1.5em")
			.attr("fill", "black")
			.attr("y", -9)
			.text(function(field){ return field; });

	PC.g.brush = PC.g.axis.append("g")
		.attr("class", "brush")
		.each(function(field){
			d3.select(this)
				.call(PC.y[field].brush = d3.brushY().extent([[-12, 0], [12, PC.height]]).on("brush", PC.brush(field)));
		});

	PC.update();
};

PC.reset = function(){
	PC.g.brush.each(function(field){
		d3.select(this).call(PC.y[field].brush.move, null);
	});
};

</script>
</html>